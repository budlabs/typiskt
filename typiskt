#!/usr/bin/env bash

___printversion(){
  
cat << 'EOB' >&2
typiskt - version: 2020.06.25.33
updated: 2020-06-25 by budRich
EOB
}


# environment variables
: "${XDG_CONFIG_HOME:=$HOME/.config}"
: "${TYPISKT_CACHE:=$HOME/.cache/typiskt}"
: "${TYPISKT_TIME_FORMAT:="%y/%m/%d"}"


#
# 2020 June 14
#
# The author disclaims copyright to this source code.
# In place of a legal notice, here is a blessing:
#
#    May you do good and not evil.
#    May you find forgiveness for yourself and forgive others.
#    May you share freely, never taking more than you give.
#
###############################################################

main() {

  _source="$(readlink -f "${BASH_SOURCE[0]}")"
  _dir="${_source%/*}"
  _bookmarkfile=""
  _exercisefile=""
  _underline=""

  ((__o[list])) && listcorpuses

  declare -i _height _width _maxW _difficulty
  declare -i _activepos _nextpos _lastpos
  declare -i _time _t _oldstatus _bookmark
  declare -i _restart=1 _clicks=0 _badclicks=0
  declare -i _seed _lastexercise _start
  declare -i _underlinewidth=14

  declare -a exercises
  declare -a wordlist   # wordlist as array
  declare -a words      # ${wordlist[${words[-1]}]}=next
  declare -a wordmasks  # specialsfile as array
  declare -a nextline activeline

  declare -A pos

  : "${_seed:=${__o[seed]:-$(od -An -N3 -i /dev/random)}}"
  RANDOM=$_seed

  declare -A m # mask array
  masks=(random difficulty time bookmark linebreak loop)
  for ((i=0;i<${#masks[@]};i++)); do 
    m[${masks[$i]}]=$((1<<i))
  done ; unset 'masks[@]'

  _mode=words
  [[ -n ${__o[exercise]}  ]] && _mode=exercise
  [[ -n ${__o[source]}    ]] && _mode=source
  [[ -n ${__o[book]}      ]] && _mode=book

  declare -i _prop # mode prpoperties
  case "$_mode" in
    words     ) _prop=$((m[random] | m[difficulty] | m[time] | m[loop])) ;;
    source    ) _prop=$((m[linebreak])) ;;
    exercise  ) _prop=$((0)) ;;
    book      ) _prop=$((m[difficulty] | m[time] | m[bookmark] | m[loop])) ;;
  esac

  makelist

  ((_prop & m[bookmark])) && {
    _bookmarkfile=$TYPISKT_CACHE/bookmarks/${__o[$_mode]##*/}
    [[ -f $_bookmarkfile ]] || {
      mkdir -p "${_bookmarkfile%/*}"
      echo 0 > "$_bookmarkfile"
    }
  }

  : "${_time:=${__o[time]:-60}}"
  ((_prop & m[time])) || _time=0
  
  ((_prop & m[difficulty])) && {

    _difficulty=$(( __o[difficulty] < 1  ? 0 : 
                    __o[difficulty] < 11 ? __o[difficulty] :
                    __o[difficulty] > 10 ? 10 : 0 ))

    ((_difficulty)) && {
      mapfile -t wordmasks < "$_dir/wordmasks"
      _difficulty=$(( ${#wordmasks[@]} * ((11-_difficulty) +4) ))
    }

  }

  
  initscreen

  declare -A _c
  for k in {0..7}; do 
    _c[f$k]=$(tput setaf "$k")
    _c[b$k]=$(tput setab "$k")
  done
  _c[res]=$(tput sgr0)
  _c[sc]=$(tput sc)
  _c[rc]=$(tput rc)
  _c[civis]=$(tput civis)
  _c[cnorm]=$(tput cnorm)

  blank=$(printf "%${_width}s" " ")

  while ((_restart)); do
    while ((_restart)); do starttest ; done
    results
  done

}

___printhelp(){
  
cat << 'EOB' >&2
typiskt - touchtype training for dirt-hackers


SYNOPSIS
--------
typiskt [--corpus|-c WORDLIST] [--difficulty|-d INT] [--time|-t SECONDS] [--width|-w WIDTH] [--seed|-s INT]
typiskt --book|-b TEXTFILE [--difficulty|-d INT] [--time|-t SECONDS] [--width|-w WIDTH]
typiskt --source|-u SOURCECODE [--width|-w WIDTH]
typiskt --exercise|-e DIR|FILE [--width|-w WIDTH]
typiskt --list|-l
typiskt --help|-h
typiskt --version|-v

OPTIONS
-------

--corpus|-c WORDLIST  

--difficulty|-d INT  

--time|-t SECONDS  

--width|-w WIDTH  

--seed|-s INT  

--book|-b TEXTFILE  

--source|-u SOURCECODE  

--exercise|-e FILE  

--list|-l  

--help|-h  
Show help and exit.


--version|-v  
Show version and exit.
EOB
}


cleanup() {
  # clear out standard input
  read -rt 0.001 && cat </dev/stdin>/dev/null

  # tput reset
  tput rmcup
  tput cnorm
  stty echo
  tput sgr0
  exit 0
}

set -E
trap '[ "$?" -ne 77 ] || exit 77' ERR

ERX() { >&2 echo  "[ERROR] $*" ; exit 77 ;}
ERR() { >&2 echo  "[WARNING] $*" ;}
ERM() { >&2 echo  "$*" ;}
ERH(){
  ___printhelp >&2
  [[ -n "$*" ]] && printf '\n%s\n' "$*" >&2
  exit 77
}

highscore() {
  local f=$TYPISKT_CACHE/scorefile tmp wpm=$1 score=$2
  declare -i t=$3 i

  [[ -n $f ]] && {

    tmp=$(mktemp)

    mkdir -p "${f%/*}"

    [[ -n $wpm ]] && {
      echo "$score $wpm $t" >> "$f"
      sort -rn "$f" > "$tmp" && mv -f "$tmp" "$f"
    }

    mapfile -t tt < "$f"
    local c ct cs dummy
    dummy=" 100.99 $(date +"$TYPISKT_TIME_FORMAT")"

    for ((i=0;i<7;i++)); do
      if [[ -n ${tt[$i]} ]]; then
        c=${tt[$i]#* } ct=${c#* } cs=${c% *}
        ((ct == t)) && echo -en "*${_c[b2]}" || echo -n " "
        printf '%6.2f ' "$cs"
        echo -n "$(date -d @"$ct" +"$TYPISKT_TIME_FORMAT")"
        ((ct == t)) && echo -ne "${_c[res]}"
        echo "${_c[f4]}▕${_c[res]}"
      else
        echo "${dummy//[^[:space:]]/ }${_c[f4]}▕${_c[res]}"
      fi
    done
  }
}
# ▕   ▎ 

initscreen() {

  read -r _height _width < <(stty size)

  # max width, set with -w or default to width-2
  : "${_maxW:=${__o[width]:-$_width}}"
  _maxW=$(((_width-2)<_maxW?_width-2:_maxW))

  pos[pY]=$(( (_height/2) - 2))
  pos[aY]=$(( pos[pY]+3 ))
  pos[aX]=$(( (_width/2) - (_maxW/2) ))
  pos[tY]=$(( pos[aY]+3 ))
  pos[tX]=$(( (_width/2) - (5/2) ))
  pos[fY]=$(( pos[pY]+1 ))
  pos[fX]=$(( (_width/2) - (_underlinewidth/2) ))
  pos[pX]=$(( pos[fX]+1 ))

  local f
  f=$(printf "%${_underlinewidth}s" " ")  f=${f// /─}
  _underline="\e[${pos[fY]};${pos[fX]}H$f"

  stty -echo
  tput smcup
  tput civis
  tput clear

  trap cleanup HUP TERM EXIT INT
}

listcorpuses() {
  ls "$_dir/wordlists" >&2
  exit
}

makelist() {

  local list exd exf tmpf
  tmpf=$(mktemp)

  case "$_mode" in

    words ) list="$_dir/wordlists/${__o[corpus]:-english}" ;;

    ( book )
      # list="$_dir/text/${__o[book]}"
      list=${__o[book]}
      [[ -f $list ]] || ERX "cannot find $list"
      wordsfromfile "$list" > "$tmpf"
      list=$tmpf
    ;;

    ( source )
      list=${__o[source]}
      [[ -f $list ]] || ERX "cannot find $list"
      __o[width]=$(wc -L < "$list")
      wordsfromfile "$list" > "$tmpf"
      list=$tmpf
    ;;

    ( exercise )
      # exd - shorthand for exercise directory/name 
      # exf - shorthand for exercise file/number

      [[ -f ${exd:=${__o[exercise]}} ]] \
        && exf=$exd && exd=${exf%/*}
      [[ -d $exd ]] || ERX could not find exercise "$exd"

      # file to store index of last exercise
      _exercisefile=$TYPISKT_CACHE/excersices/$exd

      # if ARG to --exercise is a directory
      # all files in the dir is added to 'exercises'
      # array. _lastexercise will be either the
      # content of _exercisefile or 0
      # exf=${exercises[$_lastexercise]}

      [[ -f $exf ]] || {
        _lastexercise=0
        [[ -f $_exercisefile ]] \
          && _lastexercise=$(< "$_exercisefile")

        < <(find "$exd" -type f -printf '%f\n' | sort -n) \
          mapfile -t exercises 

        exf="$exd/${exercises[$_lastexercise]}"
      }

      list="$exf"
    ;;
  esac

  [[ -f $list ]] || ERX "cannot find $list"
  mapfile -t wordlist < "$list"
  rm "$tmpf"
}

nextword() {

  ((_activepos == _lastpos)) && setline

  _activeword=${activeline[$_nextpos]}
  _activelength=${#_activeword}
  _activepos=$_nextpos
  _nextpos=$(( _activepos+(_activelength+1) ))
  setstatus 3

  _string=""

  # reset prompt
  op+="\e[${pos[pY]};0H${blank}\e[${pos[pY]};${pos[pX]}H"

}

randomize() {

  local last next
  declare -i t n

  # 9*time ~ 500wpm
  n=$((_time*9))
  unset 'words[@]'

  if ((_prop & m[random])); then

    for ((i=0; i<n; i++)); do
      next=$((RANDOM%${#wordlist[@]}))
      ((next == last)) && next=$((RANDOM%${#wordlist[@]}))
      words+=("$next")
      last=$next
    done

  elif ((_prop & m[bookmark])); then

    [[ -f $_bookmarkfile ]] && _bookmark=$(< "$_bookmarkfile")

    ((n+=_bookmark))
    eval "words=({$n..$_bookmark})"
  else
    t=$((${#wordlist[@]}-1))
    
    eval "words=({$t..0})"
  fi
}

results() {

  declare -i clicksum bh bw nextex time

  time=$((SECONDS-_start))

  clicksum=$((_clicks-_badclicks))

  local key block acc msg=""

  tput clear
  tput civis

  acc=$(bc -l <<< "scale=3;(100-($_badclicks/$clicksum)*100)")
  wpm=$(bc -l <<< "scale=2;($clicksum/$time)*12")

  case "$_mode" in
    exercise ) ;;
    words    ) ;;
    source   ) ;;
    book     ) ;;
  esac

  [[ -d ${__o[exercise]} ]] && ((${acc%.*} > 96 )) && {
    nextex=$((_lastexercise+1<${#exercises[@]}
             ?_lastexercise+1:0))
    
    mkdir -p "${_exercisefile%/*}"
    echo "$nextex" > "$_exercisefile"
    msg+="\e[${pos[aY]};${pos[aX]}Haccuracy: ${_c[f2]}$acc%${_c[res]}"
    msg+="\e[$((pos[aY]+1));${pos[aX]}Haverage WPM: $wpm"
    msg+="\e[$((pos[aY]+2));${pos[aX]}Hpress escape for next exercise"
  }
    
  if [[ -n ${__o[exercise]} ]]; then
    makelist
    tput clear
    ((${acc%.*} > 96 )) || {
      msg+="\e[${pos[aY]};${pos[aX]}Haccuracy: ${_c[f1]}$acc%${_c[res]}"
      msg+="\e[$((pos[aY]+1));${pos[aX]}Haverage WPM: $wpm"
      msg+="\e[$((pos[aY]+2));${pos[aX]}Hpress escape to restart exercise"
    }

  else


    score=$(bc  <<< "(($wpm*$acc)*(1+$_difficulty)/100)")
    score=${score%.*}

    [[ -f $_bookmarkfile ]] && {
      echo "$((_bookmark+_words))" > "$_bookmarkfile"
    }

    block=$(
      printf 'WPM:      %6.2f\n' "$wpm"
      printf 'accuracy:%6.1f%% ' "$acc"
      echo -ne "(${_c[f2]}$clicksum${_c[res]}"
      echo -e  "|${_c[f1]}$_badclicks${_c[res]})"
    )

    if ((_time >= 60)); then
      ep=$EPOCHSECONDS
      hs=$(highscore "$wpm" "$score" "$ep")
      grep '\*' <<< "$hs" >/dev/null && \
        msg="A winner is (You)!"$'\n\n'

      poss=$(grep -n "$ep" "$TYPISKT_CACHE/scorefile")
      msg+="position: ${poss%%:*}"$'\n'
      msg+="score:    ${score}"
    else
      hs=$(highscore)
      msg=$(printf '%s\n' \
        "tests under 60 seconds" \
        "are not added to the"   \
        "scoreboard"             \
      )
    fi

    block+=$'\n\n'"$msg"

    comb=$(paste -d " " <(echo "$hs") - <<< "$block")
    
    # wc -L "always" report 24 characters more...
    declare -i magic=32

    bw=$(wc -L <<< "${comb}")
    bw=$((bw-magic))

    bx=$(( (_width/2) -  ((bw)/2) ))
    
    # don't print highscore in narrow windows
    (( bw > (_width-2) )) && {
      bx=1
      comb="$block"
    }

    bi=$(printf "%${bx}s" " ")
    comb="$bi${comb//$'\n'/$'\n'${bi}}"
    comb="$comb"

    bh=$(wc -l <<< "$comb")
    by=$(( (_height/2) - (bh/2) ))

    msg="\e[${by};0H${comb}"
  fi

  echo -en "$msg"

  while :; do
    IFS= read -rsn1 key || continue

    if [[ $key = $'\u1b' ]]; then
      read -rsn2 -t 0.001 && continue 
      _restart=1 ; break
    elif [[ $key = Q ]]; then
      break
    fi
 
  done
  tput clear
}

setline() {
  # copies nextline to activeline
  # call makeline to create new nextline
  # clear both old lines and print the two new ones

  local k

  ((pos[aX])) && indent="$(printf "%${pos[aX]}s" " ")"

  unset 'activeline[@]'
  for k in "${!nextline[@]}"; do
    activeline[$k]=${nextline[$k]}
    _lastpos=$k
  done

  _nextpos=0
  makeline

  op+="\e[${pos[aY]};0H$blank\n${blank}\e[${pos[aY]};0H"
  op+="$indent${activeline[*]}\n"
  op+="$indent${nextline[*]}"

}

makeline() {

  # creates new nextline array
  # add words to array, as long as they fit in _maxW

  declare -i ll wl j
  local w

  unset 'nextline[@]'

  while ((${#words[@]})); do
    wln=${words[-1]}
    w=${wordlist[${words[-1]}]}

    ((_difficulty)) && {

      j=$((RANDOM%_difficulty ))
      if [[ -n ${wordmasks[$j]} ]]; then
        w=${wordmasks[$j]/W/$w}
      elif ((j == (${#wordmasks[@]}+1) )); then
        w="$((RANDOM%1111111))"
      elif ((j == (${#wordmasks[@]}+2) )); then
        w=budlabs
      elif ((j == (${#wordmasks[@]}+3) )); then
        w="${w^}"
      elif ((j == (${#wordmasks[@]}+4) )); then
        w="${w^^}"
      fi

    }

    [[ $w = "@@EOL" ]] && {
      unset 'words[-1]'
      unset "wordlist[$wln]"
      break
    }

    wl=${#w}

    (( (ll+=(wl+1)) > _maxW )) && [[ -z ${__o[source]} ]] && break

    # index in array is also xposition
    nextline+=([$((ll-(wl+1)))]="$w")

    unset 'words[-1]'

  done

}

setstatus() {

  # changes color of "_activeword"
  # 1=red, 2=green, 3=yellow

  local style status=$1

  op+="${_c[civis]}${_c[sc]}"
  style="${_c[f$status]}${_activeword}${_c[res]}"
  op+="\e[${pos[aY]};$((_activepos+1+pos[aX]))H${style}"
  # op+="\e[${pos[pY]};$((pos[pX]+${#_string}))H"
  op+="${_c[cnorm]}${_c[rc]}"

  _oldstatus=$status
}

starttest() {

  local key c1 c2
  declare -i lasttime=-1 status sl cl

  _clicks=0  _badclicks=0 _words=0 _start=0 _activepos=-1
  _string=""

  op=$_underline

  [[ -n ${__o[exercise]} ]] && ((pos[pY]>1)) \
    && op+="\e[1;1Hexercise ${_exercisefile##*/} ($((_lastexercise+1))/${#exercises[@]})"

  randomize
  makeline
  setline
  nextword
  ((_time)) && timer

  while : ; do

    ((_start && SECONDS>_t && _time)) && break
    ((_time || ${#wordlist[@]}!=_words)) || break

    # update screen
    [[ -n $op ]] && { echo -en "$op" ; op="" ;}

    ((_start && SECONDS != lasttime && _time)) && timer
    
    # https://stackoverflow.com/a/46481173
    IFS= read -rsn1 key || continue

    # any graphical character
    if [[ $key =~ [[:graph:]] ]]; then
      _string+=$key

      # start the timer
      ((_start)) || { _start=$SECONDS ; _t=$((_time+SECONDS)) ;}

      nextchar=${_activeword:$((${#_string}-1)):1}
      [[ $key = "$nextchar" ]] && status=$_oldstatus \
                               || status=1
      
      ((++_clicks && status == 1 && _badclicks++))

    # space, submit word (empty $key == Enter)
    elif [[ $key = " " || -z $key ]]; then
      (( _words++ + _clicks++ ))
      ((_oldstatus != 2 && ++_badclicks)) && {
        
        ((_oldstatus == 1 || _activepos == _lastpos)) \
          || setstatus 1

        sl=${#_string}
        cl=$((sl>_activelength?sl:_activelength))
        for ((i=0;i<cl;i++)); do
          c1=${_string:$i:1} c2=${_activeword:$i:1}
          [[ $c1 = "$c2" ]] || ((_badclicks++))
        done
      }
      nextword
      continue
    # https://askubuntu.com/a/299469
    # backspace key
    elif [[ $key = $'\177' ]]; then
      ((${#_string}<1 && _badclicks++)) && continue
      key=$'\b \b'
      _string=${_string:0:-1}

      [[ $_string = "${_activeword:0:${#_string}}" ]] \
        && status=3 || status=1

      # penalty for erasing good char
      ((_oldstatus == 1 || _badclicks++)) 
    elif [[ $key = $'\u1b' ]]; then
      # catch arrowkeys etc
      read -rsn2 -t 0.001 key && {
        # shift exercise
        [[ $_mode = exercise ]] || continue
        case "$key" in
          '[D'|'[A' )  # left/up
            nextex=$((_lastexercise-1<0
                     ?${#exercises[@]}-1:_lastexercise-1))
          ;;
          '[B'|'[C' )  # down/right
            nextex=$((_lastexercise+1<${#exercises[@]}
                     ?_lastexercise+1:0))
          ;;
          * ) continue ;;
        esac

        echo "$nextex" > "$_exercisefile"
        makelist
        return
      }

      # pressing escape will restart the game
      return  
    else
      continue
    fi

    [[ $_activeword = "$_string" ]] && status=2

    ((status == _oldstatus)) || setstatus $status
    op+="$key"

  done

  _restart=0
}

timer() {
  declare -i m s remaining 

  remaining=$((_t-SECONDS))
  ((lasttime==-1)) && remaining=$((_time))
  m=$(( remaining/60 ))
  s=$(( remaining%60 ))

  op+="${_c[civis]}${_c[sc]}"
  op+="\e[${pos[tY]};${pos[tX]}H$(printf '%02d:%02d' $m $s)"
  op+="${_c[cnorm]}${_c[rc]}"

  lasttime=$SECONDS

}

wordsfromfile() {
  local f=$1

  declare -i lb=0
  ((_prop & m[linebreak])) && lb=1

  awk -v lb=$lb '
  /./ {
    for (i=1;i<=NF;i++) {
      word=$i
      print word
    }
    if (lb==1) print "@@EOL"
  }
  ' "$f"
}


declare -A __o
options="$(
  getopt --name "[ERROR]:typiskt" \
    --options "c:d:t:w:s:b:u:e:lhv" \
    --longoptions "corpus:,difficulty:,time:,width:,seed:,book:,source:,exercise:,list,help,version," \
    -- "$@" || exit 77
)"

eval set -- "$options"
unset options

while true; do
  case "$1" in
    --corpus     | -c ) __o[corpus]="${2:-}" ; shift ;;
    --difficulty | -d ) __o[difficulty]="${2:-}" ; shift ;;
    --time       | -t ) __o[time]="${2:-}" ; shift ;;
    --width      | -w ) __o[width]="${2:-}" ; shift ;;
    --seed       | -s ) __o[seed]="${2:-}" ; shift ;;
    --book       | -b ) __o[book]="${2:-}" ; shift ;;
    --source     | -u ) __o[source]="${2:-}" ; shift ;;
    --exercise   | -e ) __o[exercise]="${2:-}" ; shift ;;
    --list       | -l ) __o[list]=1 ;; 
    --help       | -h ) ___printhelp && exit ;;
    --version    | -v ) ___printversion && exit ;;
    -- ) shift ; break ;;
    *  ) break ;;
  esac
  shift
done

[[ ${__lastarg:="${!#:-}"} =~ ^--$|${0}$ ]] \
  && __lastarg="" 


main "${@:-}"


